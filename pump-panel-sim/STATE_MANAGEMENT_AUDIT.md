# State Management Audit Report
**Date:** 2025-10-14  
**Auditor:** Kilo Code  
**Phase:** 5.1 - State Management Unification

---

## Executive Summary

**üî¥ CRITICAL FINDING: Dual State Management System Detected**

The Fire Pump Panel Simulator currently operates with **TWO SEPARATE STATE MANAGEMENT SYSTEMS** running in parallel, causing significant code duplication, maintenance burden, and potential for state inconsistency.

### Key Findings:
- üî¥ **System Duplication:** SimState and PumpState coexist with ~70% overlapping properties
- üü° **Dual Update Paths:** UI updates both state systems independently in SimulatorUI.tsx
- üü¢ **Good Type Safety:** Both systems have strong TypeScript typing
- üî¥ **Inconsistent Data Flow:** Two animation loops, two simulation engines
- üü° **Global Mutable State:** Governor state stored in global variable in engine.ts

### Recommendation:
**CONSOLIDATE to single state system** - This is a clear case where unification will significantly improve maintainability, reduce bugs, and simplify the codebase.

---

## 1. State Structure Analysis

### 1.1 Identified State Systems

#### System A: SimState (state.ts + SimulationContext.tsx)
**Location:** [`src/sim/state.ts`](src/sim/state.ts:60)  
**Management:** React Context + useReducer  
**Update Pattern:** Action dispatch + reducer  

```typescript
interface SimState {
  pump: Pump;                          // Engine & pump settings
  discharges: Record<string, Discharge>; // Discharge line states
  intakes: Record<string, Intake>;     // Intake line states
  elevationFt: number;
  tankToPumpOpen: boolean;
  tankFillRecircPct: number;
  primerActive: boolean;
  primed: boolean;
  isActivePriming: boolean;
  primingProgress: number;
}
```

#### System B: PumpState (model.ts + engine.ts)
**Location:** [`src/sim/model.ts`](src/sim/model.ts:136)  
**Management:** Local state + simulateStep function  
**Update Pattern:** Direct state transformation  

```typescript
interface PumpState {
  throttle: number;
  waterSource: WaterSource;
  intakePsi: Record<IntakeId, number>;
  dischargeValvePct: Record<DischargeId, number>;
  lineConfigs: Record<DischargeId, LineConfig>;
  foam: FoamSystem;
  tankGallons: number;
  engineRpm: number;
  interlocks: PumpInterlocks;
  runtime: PumpRuntime;
  drv: DRVState;
  dischargePsi: number;
  // ... 15+ more properties
}
```

### 1.2 Property Overlap Analysis

| Property Domain | SimState | PumpState | Overlap % |
|----------------|----------|-----------|-----------|
| Pump/Engine Control | ‚úì (pump.engaged, pump.rpm, pump.setpoint) | ‚úì (interlocks.engaged, runtime.rpm, throttle) | ~80% |
| Governor | ‚úì (pump.governor) | ‚úì (runtime.governor) | 100% |
| Discharge Lines | ‚úì (discharges Record) | ‚úì (dischargeValvePct + lineConfigs) | ~70% |
| Foam System | ‚úì (pump.foamTankGallons, pump.foamSystemEnabled) | ‚úì (foam: FoamSystem) | ~60% |
| DRV | ‚úì (pump.drv) | ‚úì (drv: DRVState) | 100% |
| Priming | ‚úì (primerActive, primed, primingProgress) | ‚úì (primerActive, primed, primerTimeRemaining) | ~90% |
| Water Source | ‚úì (intakes with source) | ‚úì (waterSource) | Conceptual overlap |
| Tank Controls | ‚úì (tankToPumpOpen, tankFillRecircPct) | ‚úì (tankToPumpOpen, tankFillRecircPct) | 100% |

**Overall Overlap: ~70%** of functionality is duplicated between the two systems.

### 1.3 Unique Properties

**SimState Only:**
- `elevationFt` - Used in hydraulic calculations
- `isActivePriming` - Priming status flag

**PumpState Only:**
- `lineConfigs` - Static discharge line configurations
- `foam.enabledLines: Set<DischargeId>` - Per-line foam tracking
- `warnings: Set<string>` - Active warnings collection
- `pumpTempF`, `engineTempF` - Temperature monitoring
- `isCavitating` - Cavitation state
- `overpressureDurationSec`, `burstLines` - Overpressure tracking

---

## 2. Dual System Usage Pattern

### 2.1 Data Flow Diagram

```
USER INTERACTION
     ‚Üì
handleControlChange (SimulatorUI.tsx)
     ‚Üì
     ‚îú‚îÄ‚Üí dispatch(action) ‚Üí SimState reducer ‚Üí SimulationContext
     ‚îÇ                                              ‚Üì
     ‚îÇ                                         solveHydraulics
     ‚îÇ                                              ‚Üì
     ‚îÇ                                           result
     ‚îî‚îÄ‚Üí setPumpState ‚Üí PumpState
                           ‚Üì
                     simulateStep
                           ‚Üì
                      diagnostics
```

### 2.2 Problem: Duplicate Updates

In [`SimulatorUI.tsx:113-242`](src/ui/SimulatorUI.tsx:113), every control change triggers:
1. **Dispatch to SimState** (lines 151-187)
2. **Direct update to PumpState** (lines 191-241)

This creates two sources of truth for the same data, leading to:
- Code duplication (~80 lines of duplicate update logic)
- Risk of state drift if one update path is forgotten
- Difficult to maintain consistency
- Testing complexity (must test both paths)

### 2.3 Animation Loop Duplication

**Loop 1:** SimulationContext.tsx lines 34-57
- Dispatches TICK action every 100ms
- Updates SimState via reducer
- Runs solveHydraulics

**Loop 2:** SimulatorUI.tsx lines 79-110
- Updates every frame via requestAnimationFrame
- Calls simulateStep with PumpState
- Independent of Loop 1

---

## 3. Type Safety Review

### 3.1 Strengths ‚úÖ

1. **Explicit Typing:** All properties have explicit types
2. **Union Types:** Proper discriminated unions (`Governor`, `WaterSource`, `NozzleType`)
3. **No `any` Types:** Zero usage of `any` in state definitions
4. **Interface Documentation:** Good JSDoc comments on most interfaces

### 3.2 Opportunities üü°

1. **Branded Types for Units:** Consider branded types for physical units:
   ```typescript
   type PSI = number & { __brand: 'PSI' };
   type GPM = number & { __brand: 'GPM' };
   type RPM = number & { __brand: 'RPM' };
   ```

2. **Enum vs String Literals:** Currently using string literal unions (good), but could add const enums for better autocomplete:
   ```typescript
   export const GovernorMode = {
     RPM: 'RPM',
     PRESSURE: 'PRESSURE',
   } as const;
   ```

3. **Optional vs Required:** Some ambiguity in initialization:
   - `Discharge.foamPct` should probably be required (currently is)
   - `PumpState.warnings` initialized as Set vs Array inconsistency

---

## 4. State Update Patterns

### 4.1 SimState Updates

**Pattern:** Action dispatch ‚Üí Reducer ‚Üí Immutable updates  
**Location:** [`actions.ts:34-191`](src/sim/actions.ts:34)

**Strengths:**
- ‚úÖ Pure reducer function
- ‚úÖ Immutable updates using spread operators
- ‚úÖ Type-safe action creators
- ‚úÖ Interlock validation before updates

**Weaknesses:**
- ‚ö†Ô∏è TICK action (line 138) calls `updateTimeBasedState` which returns partial state
  - This bypasses the reducer pattern partially
  - Creates implicit side effects

### 4.2 PumpState Updates

**Pattern:** Function transformation ‚Üí Direct mutation allowed  
**Location:** [`engine.ts:275-744`](src/sim/engine.ts:275)

**Strengths:**
- ‚úÖ Single comprehensive update function
- ‚úÖ Clear step-by-step logic
- ‚úÖ Diagnostic output alongside state

**Weaknesses:**
- ‚ö†Ô∏è Global mutable state for governor (line 257)
- ‚ö†Ô∏è Direct mutation of `currentState` in some places (line 486-492)
- ‚ö†Ô∏è Complex function (460+ lines) - hard to test

---

## 5. Computed vs Stored State

### 5.1 Incorrectly Stored (Should be Computed)

#### In SimState:
1. **`pump.pdp`** (line 49) - Should be computed from flow and RPM
   - Currently stored but also computed in solver
   - Creates redundancy

2. **`pump.intakePsi`** (line 50) - Should be computed from water source
   - Computed in solver.ts but also stored

#### In PumpState:
1. **`dischargePsi`** (line 171) - Computed value, correctly updated each frame
   - Actually OK - represents "current reading" on gauge

2. **`totalFlowGpm`** (line 180) - Sum of discharge flows
   - Could be computed on-demand, but OK for performance

### 5.2 Correctly Computed

‚úÖ **`SolverResult`** - Not stored in state, computed each render  
‚úÖ **Friction losses** - Computed in hydraulics functions  
‚úÖ **Required PDP** - Computed from nozzle requirements  

### 5.3 Recommendation

**Remove from SimState:**
- `pump.pdp` - Redundant with solver output
- `pump.intakePsi` - Redundant with solver output

These should only exist in `SolverResult` and not be stored in persistent state.

---

## 6. State Initialization

### 6.1 SimState Initialization

**Function:** [`createInitialState()`](src/sim/state.ts:76)  
**Quality:** ‚≠ê‚≠ê‚≠ê‚≠ê (4/5 stars)

**Strengths:**
- ‚úÖ Complete initialization of all properties
- ‚úÖ Sensible defaults (pump off, valves closed)
- ‚úÖ Proper nested object structure

**Issues:**
- ‚ö†Ô∏è Hard-coded discharge line IDs (xlay1, xlay2, etc.)
- ‚ö†Ô∏è Magic numbers (20 gal foam, 200 ft hose)
- ‚ö†Ô∏è No validation of initial values

### 6.2 PumpState Initialization

**Function:** [`createInitialPumpState()`](src/sim/pierce-puc.ts:160)  
**Quality:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (5/5 stars)

**Strengths:**
- ‚úÖ Comprehensive with all properties
- ‚úÖ Uses constants from pierce-puc configuration
- ‚úÖ Detailed comments explaining each default
- ‚úÖ Type-safe construction

**Issues:**
- None significant - this is well done

### 6.3 Discrepancy

The two initialization functions create different starting states:
- **SimState:** 6 discharge lines
- **PumpState:** 10 discharge lines
- **SimState:** 2 intakes
- **PumpState:** 3 intakes

This inconsistency is a red flag for the dual-system approach.

---

## 7. Integration Points & Data Flows

### 7.1 Component Integration Map

```
App.tsx
  ‚îú‚îÄ SimulationProvider (SimulationContext)
  ‚îÇ    ‚îú‚îÄ state: SimState
  ‚îÇ    ‚îú‚îÄ result: SolverResult
  ‚îÇ    ‚îî‚îÄ dispatch: Action dispatcher
  ‚îÇ
  ‚îî‚îÄ SimulatorUI
       ‚îú‚îÄ Uses: useSimulation() hook ‚Üí SimState
       ‚îú‚îÄ Local: pumpState: PumpState
       ‚îÇ
       ‚îú‚îÄ Panel (PixiJS)
       ‚îÇ    ‚îî‚îÄ Props: pumpState (PumpState only!)
       ‚îÇ
       ‚îú‚îÄ StatusHUD
       ‚îÇ    ‚îî‚îÄ Props: Mixed (state.pump.governor, result.warnings)
       ‚îÇ
       ‚îî‚îÄ TrainingControls
            ‚îî‚îÄ Props: pumpState (PumpState only!)
```

### 7.2 Critical Finding: PixiJS Only Uses PumpState

The [`Panel`](src/ui/Panel.tsx:27) component and all PixiJS rendering **only** receives `PumpState`.  
This means **SimState is never directly used for rendering the main pump panel**.

**Current Flow:**
1. User interacts with PixiJS controls
2. onChange callback to SimulatorUI
3. SimulatorUI updates **both** SimState and PumpState
4. Panel re-renders with PumpState
5. SimState + SolverResult used only for StatusHUD warnings

### 7.3 Performance Analysis

**Re-render triggers:**
- SimState change ‚Üí solveHydraulics (expensive) ‚Üí re-render
- PumpState change ‚Üí simulateStep (expensive) ‚Üí re-render

Both run independently, causing **double computation**!

**Unnecessary Re-renders:**
- StatusHUD depends on both state and result ‚Üí re-renders on every change
- Panel depends only on pumpState ‚Üí correct optimization

---

## 8. Documentation & Comments

### 8.1 Quality Assessment

**SimState/Actions:**
- ‚≠ê‚≠ê‚≠ê (3/5) - Basic documentation, missing detailed state relationships

**PumpState/Model:**
- ‚≠ê‚≠ê‚≠ê‚≠ê (4/5) - Excellent JSDoc comments on interfaces

**Engine.ts:**
- ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (5/5) - Comprehensive function-level documentation

### 8.2 Missing Documentation

1. State transition diagrams
2. Relationship between SimState and PumpState
3. Migration guide (if one system is to be deprecated)
4. Decision rationale for dual systems

---

## 9. Consolidation Recommendation

### 9.1 Why Consolidation is Warranted

‚úÖ **Significant Duplication:** 70% property overlap  
‚úÖ **Dual Update Paths:** Every control change updates both systems  
‚úÖ **No Clear Separation:** Both track operational state, not UI vs domain  
‚úÖ **Maintenance Burden:** Changes require updating 2 places  
‚úÖ **Performance Impact:** Double computation on every frame  
‚úÖ **Risk of Desync:** One system could diverge from the other  

### 9.2 Consolidation Strategy

**Phase 1: Extend PumpState (Recommended)**
- Keep PumpState as the single source of truth
- Add missing SimState properties to PumpState
- Update Panel/PixiJS to continue using PumpState
- Remove SimState entirely

**Phase 2: Update SimulationContext**
- Change SimulationContext to manage PumpState instead of SimState
- Keep action-based dispatch pattern (good architecture)
- Update reducer to work with PumpState
- Remove parallel state updates in SimulatorUI

**Phase 3: Unify Simulation Logic**
- Merge simulateStep and solveHydraulics into single update function
- Keep computed values (SolverResult) separate
- Remove duplicate animation loops

### 9.3 Migration Benefits

üìà **Lines of Code Reduction:** ~200-300 lines  
‚ö° **Performance Improvement:** 50% reduction in computation  
üêõ **Bug Risk Reduction:** Single source of truth  
üß™ **Test Simplification:** Half the test surface area  
üìö **Maintainability:** Clear, single state structure  

---

## 10. Proposed Unified State Structure

```typescript
/**
 * Unified simulation state for fire pump panel
 * Combines operational state, configuration, and runtime data
 */
export interface UnifiedSimState {
  // ===== Engine & Pump Control =====
  engine: {
    engaged: boolean;           // Master pump ON/OFF
    rpm: number;                // Current engine RPM (700-2200)
    throttle: number;           // Throttle position (0-100)
    temperatureF: number;       // Engine temperature
  };
  
  // ===== Governor =====
  governor: {
    mode: 'RPM' | 'PRESSURE';
    setpoint: number;           // RPM or PSI depending on mode
    targetRPM: number;          // Internal PID target
    targetPDP: number;          // Internal PID target
  };
  
  // ===== Pump Hydraulics =====
  pump: {
    dischargePsi: number;       // Pump discharge pressure (gauge reading)
    intakePsi: number;          // Intake pressure (+ for hydrant, - for draft)
    intakeVacuumInHg: number;   // Intake vacuum (draft operations)
    temperatureF: number;       // Pump casing temperature
    primed: boolean;            // Pump is primed
    cavitating: boolean;        // Pump is cavitating
  };
  
  // ===== Water System =====
  water: {
    source: 'tank' | 'hydrant' | 'draft' | 'relay';
    tankGallons: number;
    tankCapacity: number;
    tankToPumpOpen: boolean;
    tankFillRecircPct: number;  // 0-100 (cooling/filling)
  };
  
  // ===== Discharge Lines =====
  discharges: Record<DischargeId, {
    config: LineConfig;         // Static configuration
    valvePosition: number;      // 0-100% open
    flowGpm: number;            // Computed flow rate
    pressurePsi: number;        // Pressure at nozzle
  }>;
  
  // ===== Intake Lines =====
  intakes: Record<IntakeId, {
    pressurePsi: number;        // Intake pressure
    ldh: boolean;               // Is LDH intake
  }>;
  
  // ===== Foam System =====
  foam: {
    enabled: boolean;           // Master foam system ON/OFF
    percent: number;            // Foam concentration (0.1-1.0%)
    tankGallons: number;
    tankCapacity: number;
    enabledLines: Set<DischargeId>;
  };
  
  // ===== DRV (Discharge Relief Valve) =====
  drv: {
    enabled: boolean;
    setpointPsi: number;
    bypassGpm: number;
  };
  
  // ===== Priming System =====
  primer: {
    active: boolean;
    timeRemaining: number;      // Seconds left in 15s cycle
  };
  
  // ===== Operational Tracking =====
  runtime: {
    totalFlowGpm: number;
    warnings: Set<string>;
    overpressureDurationSec: number;
    burstLines: Set<DischargeId>;
    elevationFt: number;        // For hydraulic calculations
  };
}
```

---

## 11. Action Items

### Priority 1: Critical (Do Now)
1. ‚úÖ Document dual system (this audit)
2. üî¥ Decide on consolidation approach
3. üî¥ Create migration plan
4. üî¥ Update architecture documentation

### Priority 2: High (Next Sprint)
1. üü° Implement unified state structure
2. üü° Update SimulationContext to use unified state
3. üü° Remove duplicate update logic in SimulatorUI
4. üü° Update Panel to use unified state

### Priority 3: Medium (Following Sprint)
1. üü¢ Merge animation loops
2. üü¢ Consolidate simulation functions
3. üü¢ Update tests
4. üü¢ Performance benchmarking

### Priority 4: Low (Cleanup)
1. ‚ö™ Remove deprecated code
2. ‚ö™ Update all documentation
3. ‚ö™ Add migration notes to README

---

## 12. Risks & Mitigation

### Risk 1: Breaking Changes
**Impact:** High  
**Mitigation:**
- Feature flag for new system
- Parallel operation during transition
- Comprehensive integration tests
- Gradual migration, one component at a time

### Risk 2: Performance Regression
**Impact:** Medium  
**Mitigation:**
- Benchmark before and after
- Profile critical paths
- Maintain separate computation results (SolverResult pattern)

### Risk 3: Lost Functionality
**Impact:** High  
**Mitigation:**
- Complete property mapping document
- Test all features before deprecation
- Keep old code commented for reference

---

## Conclusion

The current dual state system represents **significant technical debt** that should be addressed as a high priority. While both systems work independently, their coexistence creates:
- Maintenance overhead
- Performance penalties
- Risk of state inconsistency
- Developer confusion

**Recommendation: Proceed with consolidation using the strategy outlined in Section 9.**

The unified state structure proposed in Section 10 combines the best aspects of both systems:
- PumpState's comprehensive property set
- SimState's action-based update pattern
- Clear separation of concerns
- Strong typing throughout

Estimated effort: 2-3 developer weeks with thorough testing.

---

**Report End**